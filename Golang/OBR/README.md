Number of lines in my file : 1 000 000 000
First thing I explore is : how you can read data faster

```go
for scanner.Scan() {
		line := scanner.Bytes()
}

VS 

for scanner.Scan() {
		line := scanner.Bytes()
}
```

127.453307s  VS  50.734827s

We can explain this by looking at the bufio code that gives the method for the scanner object :


```go
// Bytes returns the most recent token generated by a call to Scan.
// The underlying array may point to data that will be overwritten
// by a subsequent call to Scan. It does no allocation.
func (s *Scanner) Bytes() []byte {
	return s.token
}

// Text returns the most recent token generated by a call to Scan
// as a newly allocated string holding its bytes.
func (s *Scanner) Text() string {
	return string(s.token)
}
```

We can see that the Bytes method return the data without any transformation (which make sense because data are 0 or 1). The Bytes() function reuse an internal buffer, returning the same object so there is no additional allocation.



```go
scanner := bufio.NewScanner(file)
BUFFER_SIZE := 4096*4096	
scanner.Buffer(make([]byte, BUFFER_SIZE), BUFFER_SIZE)
```

23s

Setting a larger buffer size can potentially improve the performance of reading from the file, especially when dealing with large files. Here's why:

- **Reduced System Calls**: the OS reads data in chunks, and each read operation involves a system call. By using a larger buffer, we reduce the number of syscall required to read the data because more data is read into memory in each operation. 

- **Less Overhead**: Larger buffers can reduce the overhead associated with managing the buffer itself.

- **Optimized Disk Access**: File systems often perform better when reading larger contiguous chunks of data rather than smaller scattered reads. 




```go
BUFFER_SIZE := 4096*4096	
	buffer := make([]byte, BUFFER_SIZE)
	for {
		_, err := file.Read(buffer)
		if err == io.EOF {
			break
		}
		if err != nil {
			panic(err)
		}
	}
```

15.101426s

after checking how Scanner.Scan works internally I noticed that it does a lot of things that I donâ€™t need. It manipulates the buffer object a lot
So we ca, creates our own  buffer and manage it ourselves to get more control over how much data is read at once and what happened to the data
